# The target seconds per frame
TARGET_SPF 0.02

WORLD_CHECK_CONFIG_INTERVAL 1024

# The chunk size in meters
CHUNK_SIZE 4.0

BLOB_SPACING 1.0

BLOB_BOND_DATA_BYTES 32
BLOB_BONDS_MAX 16

FLIP_NORMALS 0
PAD_VERTS 1
PAD_FACES 1

# Stop floating a vert when it moves less than VERT_FLOAT_THRESHOLD_RATIO times the average neighbor distance
# Smaller is more accurate but slower
VERT_FLOAT_THRESHOLD_RATIO 0.01f

# Stop floating a face when it moves less than FACE_FLOAT_THRESHOLD_RATIO times the average edge length
# Smaller is more accurate but slower
FACE_FLOAT_THRESHOLD_RATIO 0.01f

# Clamp the ratio of face movement over average edge length to this value
ISOSURFACE_FACE_FLOAT_EDGE_LEN_RATIO_CLAMP 1.0f

# Don't subdiv a face if it's area is less than FACE_SUBDIV_THRESH
FACE_SUBDIV_THRESH 1.0

# Which isosurface function to use
# Only enable one!
ISOSURFACE_FUNCTION_POLY 1
ISOSURFACE_FUNCTION_INV_SQ 0

ISOSURFACE_CELL_SIZE 0.5

ISOSURFACE_INFLUENCE_RAD 1.0
ISOSURFACE_EXACT_INFLUENCE 0

MESH_FACE_VERT_RATIO 2
MESH_GRID_SIZE 1.0

# Which MeshFace shuffle iterator search algorithm to use
# Only enable one!
MESH_FACE_SHUFFLE_ITERATOR_LINEAR_SEARCH 1
MESH_FACE_SHUFFLE_ITERATOR_BINARY_SEARCH 0

SPHERE_TREE_BRANCH_THRESH 4

GROUND_GRID_CELL_SIZE 16.0

SPHERETREE_RESET_COUNTER_DELAY 256

# These intervals should be a power of 2 for performance
SPHERETREE_ROTATE_TEST_INTERVAL 16
SPHERETREE_SHRINK_TEST_INTERVAL 16

SPHERETREE_ROTATE_HIT_THRESHOLD 8
SPHERETREE_SHRINK_HIT_FACTOR_THRESHOLD 2

GRIDSPHERETREE_MAX_LEVELS 32

# Which IsosurfaceScene floating strategy to use
# Only enable one!
ISOSURFACE_USE_SPHERES 1
ISOSURFACE_USE_FLOATING 0

ISOSURFACESPHERES_KEEP_BLOB_VERT_MAP 1

ISOSURFACE_EDGE_SUBDIV_THRESHOLD 1.0

# If all of the edges of a triangle are longer than this factor multiplied by the length of the longest edge, then the triangle is considered "regular".
# If a triangle is regular, it will be subdivided into three faces with a central vertex.
# If a triangle is not regular, its longest edge will be subdivided.
ISOSURFACE_REGULAR_FACTOR 0.8

ISOSURFACE_ROOT_ALGORITHM_HOUSEHOLDER 1
ISOSURFACE_ROOT_ALGORITHM_TAYLOR_SOLVE 1

ISOSURFACESCENE_SHADER_PATH "src/shaders/"

# If IsosurfaceScene should use a logarithmetic depth buffer.
# Valid values are 0 or 1
ISOSURFACESCENE_USE_LOG_DEPTH_BUFFER 1

ISOSURFACESCENE_INITIAL_TRIGGERS_BUFFER_SIZE 1024

# Defines the size of the compute shader work groups.
# Generally, if you decrease this number, you'll want to increase ISOSURFACE_COMPUTE_INITIAL_WORK_GROUP_COUNT_MULTIPLE.
# Try and keep this a power of 2.
ISOSURFACESCENE_COMPUTE_WORK_GROUP_SIZE 1024

# Defines the initial compute work group count.
# The product of this and ISOSURFACE_COMPUTE_WORK_GROUP_SIZE will be the minimum face counts buffer resize interval size in unsigned ints (4 bytes) when the number of faces increases.
# Try and keep this a power of 2.
FACEFRAGCOUNTER_INITIAL_WORK_GROUP_COUNT_MULTIPLE 1

# If N faces are needed because of subdivision, multiply by this number to find the number of faces that need to be destroyed.
# Should be slightly greater than one to reduce mesh fragmentation.
ISOSURFACESCENE_DESTROY_SUBDIV_RATIO (5/4)

MESHSCENE_IMMEDIATE_FACE_INSERTION 1

# If each mesh's transforms are stored in the MeshScene::draw_commands buffer, it forces that buffer to be completely updated every frame.
# If they are stored in a separate buffer (IsosurfaceScene::transforms), then MeshScene::draw_commands can be updated only when needed (when a face is added or removed).
# If the MeshScene::draw_commands buffer is already mostly re-created every frame, turn this on.
MESHSCENE_TRANSFORMS_IN_DRAW_COMMANDS_BUFFER 1

# When a mesh runs out of adjacent space for a new face, one of two things will happen:
# If the ratio of the number of used faces to the number of allocated faces is below this threshold, create a new partition.
# If the ratio of the number of used faces to the number of allocated faces is above this threshold, destroy faces until it's below.
MESHSCENE_DESTROY_FACES_USAGE_THRESHOLD (7/8)

# When destroying faces, destroy this number of extra faces to prevent thrashing between destroying a single face, then using it, then destroying another face...
MESHSCENE_DESTROY_FACES_EXTRA 256

# The maximum merge gap in bytes.
# When updating flags, flags separated by a gap smaller than this value will be merged.
GLBUFFER_MAX_MERGE_GAP 64

GLBUFFER_FLUSH_EXPLICIT 1
GLBUFFER_ASSERT_BINDINGS 1

GLVAO_ASSERT_BINDINGS 1

ERASABLEQUEUE_BLOCK_SIZE_BYTES 1024

FASTMATH_INT_INVERSE_MAX 65536
FASTMATH_ENABLE_INTINVERSE_FLOAT 1
FASTMATH_ENABLE_INTINVERSE_DOUBLE 0

DISABLE_CURSOR 0
MOUSE_SPEED 0.01

DEBUGPLOT3D_PIPE_PATH "debugplot3d.sock"

# Size of mesh history circular buffer. Used for predicting future mesh sizes.
MESH_HISTORY_LENGTH (30 * 60)

# Enable GlArrayBuffer defragmentation.
# Not implemented yet.
ENABLE_ARRAY_BUFFER_DEFRAG 0

# Number of bits available for sequencing events inside a single sim step
# The remaining bits (from a 64-bit integer) are used for the sim step id
SIMULATION_STATEID_SUBSTEP_BITS 32

OBJECTCONTEXT_PROVIDE_LOGGER 1

PHYSICS_CHECK_CONSERVATION 0
PHYSICS_CHECK_NULL_INTERSECTION 1

OBJECTDYNAMICS_ORIENTATION_QUATERNION 0

WFC_POINTS_PER_CUBE_METER 1.0f
WFC_NEIGHBOR_Z_DIVISIONS 9
WFC_NEIGHBOR_DIVISION_MAX_SIZE 4
WFC_NEIGHBOR_DISTANCE_THRESHOLD 8.0f

# Available functions:
#   coalesce - Try arguments in order until one returns a matching sample
#   sum - Concatenate samples from each argument
#   hashmap - Lookup matching samples from model, parameterized by <latitudeDivisions, longtitudeDivisions, divisionCapacity>(weight = 1.0f)
# After all samples are returned, one is chosen randomly, weighted
WFC_RESOLVER_GRAPH_CONFIG hashmap<5, 1, 4>()

# LookupRadius is solved for using these equations:
# pointsPerDivision = 4.0f / 3.0f * pi * (lookupRadius ^ 3) * WFC_POINTS_PER_CUBE_METER / latitudeDivisions / longtitudeDivisions;
# pointsPerDivision = divisionCapacity * DIVISION_CAPACITY_LOOKUP_MULTIPLIER;
# Increasing this multiplier will cause lookupRadius to be larger, finding more actual bbs and causing LESS air bbs to be "found" in solids (ex. underground)
# Increasing this multiplier will cause lookupRadius to be smaller, finding less actual bbs and causing MORE air bbs to be "found" in solids (ex. underground)
# To see what affect this value has on the blob count, enable DEBUG_PRINT_DIVISION_SIZE_DISTRIBUTION
DIVISION_CAPACITY_LOOKUP_MULTIPLIER 1.25f

DEBUG_PRINT_DIVISION_SIZE_DISTRIBUTION 0
DEBUG_DIVISION_SIZE_DISTRIBUTION_SAMPLES 10000


WORLDGEN_SIMPLE_ENABLED 1

HASHTREEISOSURFACE_FIELD_CHANGE_THRESHOLD 5e-2f
HASHTREEISOSURFACE_ASSERT_FACE_NORMALS 0
HASHTREEISOSURFACE_ENABLE_LOD 1
HASHTREEISOSURFACE_DETERMINISTIC_PROVOKERS 1
HASHTREEISOSURFACE_SUBDIV_LEVELS_THRESHOLD 4



# The following options are debug options, and should be turned off for release.
DEBUG_ISOSURFACESCENE_ASSERT_PROGRAMS 0
DEBUG_GLBUFFER_ASSERT_BINDINGS 0
DEBUG_WINDOW_GLFW_DEBUG_CONTEXT 0
DEBUG_FOUNTAINSOLVER_ASSERT_FREE 0
DEBUG_MESHSCENE_ASSERT_PFI_INSERTED 0
DEBUG_LITMESHSCENE_ASSERT_VERTS_UPDATED 0
DEBUG_LITMESHSCENE_ASSERT_CREATE_LIGHTS 0
DEBUG_GPUPROGRAM_WRITE_PREPROCESSED_SHADERS 0
DEBUG_ISOSURFACESCENE_CHECK_GRADIENT 0
DEBUG_MULTIDIMMATRIX_INIT_GARBAGE 0
DEBUG_ENABLE_DEBUGPLOT3D 0
DEBUG_TEMPZEROVEC_ASSERT_UNLOCKED 0
DEBUG_TEMPZEROVEC_ASSERT_ZEROED 0
DEBUG_SKYGRID_SAVE_OCTREE_COORDS 0

# Whether the color buffer should be cleared before each frame.
# This shouldn't be needed in release because the entire screen should be covered by geometry.
DEBUG_CLEAR_COLOR_BUFFER 1
